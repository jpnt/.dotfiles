#!/bin/sh
# booksort: Book sorting and place on specific folder according to file extension.
# Use `KEPUB=1 booksort *` to also convert from epub to kepub and place them separately.
set -e

normalize_name() {
    echo "$1" | sed 's/[[:space:]]\{1,\}/_/g' | awk '{
        gsub(/_+/, "_")
        n = split($0, parts, /_/)
        output = ""
        for (i = 1; i <= n; i++) {
            if (parts[i] == "") continue
            first = substr(parts[i], 1, 1)
            rest = substr(parts[i], 2)
            output = output (i > 1 ? "_" : "") toupper(first) rest
        }
        print output
    }'
}

die() {
    echo "Error: $1" >&2
    exit 1
}

[ "$#" -eq 0 ] && die "Usage: $0 <file>..."
[ "${KEPUB:-0}" -eq 1 ] && ! command -v kepubify >/dev/null && die "kepubify not found"

for FILE in "$@"; do
    [ ! -f "$FILE" ] && { echo "Skip: $FILE (not a file)" >&2; continue; }

    BASE=$(basename "$FILE")
    DIR=$(dirname "$FILE")
    
    # Extract extension, normalize to lowercase
    EXT="${BASE##*.}"
    EXT=$(echo "$EXT" | tr '[:upper:]' '[:lower:]')
    
    # Handle .kepub.epub special case
    if [ "$BASE" != "${BASE%.kepub.epub}" ]; then
        EXT="kepub"
        BASE="${BASE%.kepub.epub}.kepub.epub"
    fi
    
    case "$EXT" in
        pdf|epub|kepub|djvu) ;;
        *) echo "Skip: $FILE (unsupported: .$EXT)" >&2; continue ;;
    esac
    
    NORM=$(normalize_name "$BASE")
    DEST="$DIR/$EXT"
    mkdir -p "$DEST"
    
    # Convert epub→kepub if requested and not already kepub
    if [ "$EXT" = "epub" ] && [ "${KEPUB:-0}" -eq 1 ]; then
        KEPUB_NAME="${NORM%.epub}.kepub.epub"
        KEPUB_DEST="$DIR/kepub"
        mkdir -p "$KEPUB_DEST"
        kepubify "$FILE" -o "$KEPUB_DEST/$KEPUB_NAME"
        echo "$KEPUB_NAME → $KEPUB_DEST/"
    fi
    
    mv "$FILE" "$DEST/$NORM"
    echo "$NORM → $DEST/"
done
